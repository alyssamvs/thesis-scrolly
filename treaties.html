<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Treaty Network - Force Directed Timeline</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            background: #fff;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        svg {
            width: 100%;
            height: 100%;
        }
        
        /* Node styling */
        .node circle {
            cursor: pointer;
            transition: all 0.3s ease;
            stroke: white;
            stroke-width: 2;
        }
        
        .node:hover circle {
            stroke: #000;
            stroke-width: 3;
        }
        
        .node.highlighted circle {
            stroke: #000;
            stroke-width: 3;
        }
        
        /* Text labels */
        .node-label {
            font-size: 9px;
            fill: #000;
            pointer-events: none;  /* Ensures text doesn't block mouse events */
            font-weight: 400;
            text-anchor: start;
        }
        
        .node-label.major {
            font-size: 11px;
            font-weight: 600;
        }
        
        .year-label {
            font-size: 8px;
            fill: #666;
            pointer-events: none;  /* Ensures text doesn't block mouse events */
            text-anchor: start;
        }
        
        /* Connection lines - will use gradient */
        .link {
            fill: none;
            stroke-width: 1.5;
            opacity: 0.6;
            transition: all 0.3s ease;
        }
        
        .link:hover,
        .link.active {
            stroke-width: 2.5;
            opacity: 1;
        }
        
        /* Timeline axis */
        .timeline-axis line {
            stroke: #e0e0e0;
            stroke-width: 1;
        }
        
        .timeline-axis text {
            font-size: 11px;
            fill: #999;
            font-weight: 500;
        }
        
        .decade-marker {
            stroke: #f0f0f0;
            stroke-width: 1;
            stroke-dasharray: 2,2;
        }
        
        /* Tooltip - fixed at top-left */
        .tooltip {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 12px 15px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            pointer-events: none;
            opacity: 0;
            font-size: 10px;
            max-width: 320px;
            z-index: 1000;
            transition: opacity 0.2s;
            line-height: 1.4;
            border: 1px solid #333;
        }
        
        .tooltip-title {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 11px;
        }
        
        .tooltip-meta {
            font-size: 9px;
            opacity: 0.8;
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div id="container">
        <svg id="main-svg"></svg>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        console.log('Force-directed timeline visualization loading...');
        
        // Configuration
        const config = {
            margin: { top: 60, right: 80, bottom: 60, left: 80 },
            yearRange: [1909, 2010],
            nodeRadius: {
                treaty: 12,
                amendment: 12,
                body: 9,
                commission: 9,
                law: 6,
                regulation: 6,
                ratification: 5,
                decision: 8
            },
            highlighted: ['Treaty-Hague-1912', 'US-Harrison-1914', 'Treaty-UN-1961', 'Treaty-UN-1988', 'PE-DL22095-1978'],
            colors: {
                'League of Nations': '#08415C',
                'United Nations': '#CC2936',
                'Comunidad Andina de Naciones (CAN)': '#1B998B',
                'Organization of American States (OAS)': '#FFBE0B',
                'European Union (EU)': '#A7BBEC',
                'United States': '#7D8597',
                'Peru': '#E07A5F',
                'International': '#95A5A6'
            },
            forceStrength: {
                charge: -150,       // Repulsion between nodes
                link: 0.3,          // Link strength
                collide: 1.5        // Collision multiplier
            }
        };
        
        // Load data
        Promise.all([
            d3.json('./data/tooltip_data_template.json'),
            d3.csv('./data/drug_regulations_shortened_keys.csv')
        ]).then(([tooltipData, relationships]) => {
            console.log('Data loaded:', Object.keys(tooltipData).length, 'nodes');
            console.log('Relationships:', relationships.length);
            const nodes = processNodes(tooltipData);
            const links = processLinks(relationships, nodes);
            createVisualization(nodes, links);
        }).catch(error => {
            console.error('Error loading data:', error);
            console.log('Make sure data files are in ./data/ folder:');
            console.log('- ./data/tooltip_data_template.json');
            console.log('- ./data/drug_regulations_shortened_keys.csv');
        });
        
        function processNodes(tooltipData) {
            const nodes = [];
            
            for (const [key, data] of Object.entries(tooltipData)) {
                if (!data.year) continue;
                
                const isHighlighted = config.highlighted.includes(key);
                const baseRadius = config.nodeRadius[data.type] || 6;
                
                nodes.push({
                    id: key,
                    name: data.name,
                    shortName: data.shortened_name || data.name,  // Use shortened_name from JSON
                    year: data.year,
                    type: data.type,
                    entity: data.entity,
                    description: data.description,
                    highlighted: isHighlighted,
                    radius: isHighlighted ? baseRadius * 1.5 : baseRadius
                });
            }
            
            return nodes;
        }
        
        // No longer need shortenName function - removed
        
        function processLinks(relationships, nodes) {
            const links = [];
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            
            relationships.forEach(rel => {
                const source = nodeMap.get(rel.source);
                const target = nodeMap.get(rel.target);
                
                if (source && target) {
                    links.push({
                        source: source.id,
                        target: target.id,
                        relationship: rel.relationship,
                        // Use source node's entity for link color
                        entity: source.entity
                    });
                }
            });
            
            return links;
        }
        
        function createVisualization(nodes, links) {
            const svg = d3.select('#main-svg');
            const tooltip = d3.select('#tooltip');
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            const innerWidth = width - config.margin.left - config.margin.right;
            const innerHeight = height - config.margin.top - config.margin.bottom;
            
            svg.selectAll('*').remove();
            
            // Create defs for gradients
            const defs = svg.append('defs');
            
            const g = svg.append('g')
                .attr('transform', `translate(${config.margin.left},${config.margin.top})`);
            
            // X scale for timeline (horizontal)
            const xScale = d3.scaleLinear()
                .domain(config.yearRange)
                .range([0, innerWidth]);
            
            // Draw decade markers (vertical lines)
            const decades = d3.range(1910, 2020, 10);
            decades.forEach(decade => {
                const x = xScale(decade);
                
                g.append('line')
                    .attr('class', 'decade-marker')
                    .attr('x1', x)
                    .attr('x2', x)
                    .attr('y1', 0)
                    .attr('y2', innerHeight);
                
                g.append('text')
                    .attr('class', 'timeline-axis')
                    .attr('x', x)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '11px')
                    .style('fill', '#999')
                    .text(decade);
            });
            
            // Timeline axis at bottom
            const xAxis = d3.axisBottom(xScale)
                .tickValues(decades)
                .tickFormat(d => d);
            
            g.append('g')
                .attr('class', 'timeline-axis')
                .attr('transform', `translate(0,${innerHeight})`)
                .call(xAxis);
            
            // Convert link source/target to node references
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            links.forEach(link => {
                link.source = nodeMap.get(link.source);
                link.target = nodeMap.get(link.target);
            });
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('charge', d3.forceManyBody().strength(config.forceStrength.charge))
                .force('link', d3.forceLink(links).id(d => d.id).strength(config.forceStrength.link))
                .force('collide', d3.forceCollide().radius(d => d.radius * config.forceStrength.collide))
                .force('x', d3.forceX(d => xScale(d.year)).strength(1)) // Strong X force to timeline
                .force('y', d3.forceY(innerHeight / 2).strength(0.1)) // Weak Y force to center
                .force('bounds', forceBounds); // Keep nodes in bounds
            
            // Custom force to keep nodes within bounds
            function forceBounds() {
                nodes.forEach(node => {
                    node.x = Math.max(node.radius, Math.min(innerWidth - node.radius, node.x));
                    node.y = Math.max(node.radius, Math.min(innerHeight - node.radius, node.y));
                });
            }
            
            // Draw links with gradient fade effect
            const linkGroup = g.append('g').attr('class', 'links');
            
            const linkElements = linkGroup.selectAll('.link')
                .data(links)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke', (d, i) => `url(#gradient-${i})`)
                .on('mouseenter', function() {
                    d3.select(this).classed('active', true);
                })
                .on('mouseleave', function() {
                    d3.select(this).classed('active', false);
                });
            
            // Draw nodes
            const nodeGroup = g.append('g').attr('class', 'nodes');
            
            const nodeElements = nodeGroup.selectAll('.node')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', d => `node ${d.highlighted ? 'highlighted' : ''}`)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('mouseenter', function(event, d) {
                    showTooltip(event, d);
                    highlightConnections(d);
                })
                .on('mouseleave', function() {
                    hideTooltip();
                    unhighlightConnections();
                });
            
            // Node circles
            nodeElements.append('circle')
                .attr('r', d => d.radius)
                .attr('fill', d => config.colors[d.entity] || '#95A5A6');
            
            // Name labels (diagonal, upward and to the right)
            // Create labels for ALL nodes, but only show highlighted by default
            nodeElements.append('text')
                .attr('class', d => d.highlighted ? 'node-label major' : 'node-label')
                .attr('x', d => d.radius + 3)  // Offset to right of node
                .attr('y', d => -d.radius - 3)  // Offset above node
                .attr('text-anchor', 'start')  // Align text to start from anchor point
                .attr('transform', d => `rotate(-25, ${d.radius + 3}, ${-d.radius - 3})`)  // Rotate 45° upward
                .style('opacity', d => d.highlighted ? 1 : 0)  // Hide non-highlighted labels
                .text(d => d.shortName);
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                // Update link positions and gradients
                linkElements.each(function(d, i) {
                    const link = d3.select(this);
                    
                    // Update line position
                    link
                        .attr('x1', d.source.x)
                        .attr('y1', d.source.y)
                        .attr('x2', d.target.x)
                        .attr('y2', d.target.y);
                    
                    // Create/update gradient for this link
                    const gradientId = `gradient-${i}`;
                    let gradient = defs.select(`#${gradientId}`);
                    
                    if (gradient.empty()) {
                        gradient = defs.append('linearGradient')
                            .attr('id', gradientId);
                        
                        // Start color (darker at source)
                        gradient.append('stop')
                            .attr('offset', '0%')
                            .attr('class', 'start');
                        
                        // Middle color (lighter)
                        gradient.append('stop')
                            .attr('offset', '50%')
                            .attr('class', 'middle');
                        
                        // End color (darker at target)
                        gradient.append('stop')
                            .attr('offset', '100%')
                            .attr('class', 'end');
                    }
                    
                    // Update gradient direction based on link positions
                    gradient
                        .attr('x1', `${d.source.x}px`)
                        .attr('y1', `${d.source.y}px`)
                        .attr('x2', `${d.target.x}px`)
                        .attr('y2', `${d.target.y}px`)
                        .attr('gradientUnits', 'userSpaceOnUse');
                    
                    // Get color for this entity
                    const baseColor = config.colors[d.entity] || '#666';
                    
                    // Create lighter version for middle
                    const middleColor = d3.color(baseColor).brighter(1.5);
                    
                    // Update gradient stops
                    gradient.select('.start')
                        .attr('stop-color', baseColor)
                        .attr('stop-opacity', 0.8);
                    
                    gradient.select('.middle')
                        .attr('stop-color', middleColor)
                        .attr('stop-opacity', 0.2);
                    
                    gradient.select('.end')
                        .attr('stop-color', baseColor)
                        .attr('stop-opacity', 0.8);
                });
                
                nodeElements
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Tooltip functions
            function showTooltip(event, d) {
                const shortDesc = d.description ? 
                    (d.description.length > 150 ? d.description.slice(0, 150) + '...' : d.description) : '';
                
                tooltip
                    .style('opacity', 1)
                    .html(`
                        <div class="tooltip-title">${d.name}</div>
                        <div class="tooltip-meta">${d.year} • ${d.type} • ${d.entity}</div>
                        ${shortDesc ? `<div style="margin-top: 5px;">${shortDesc}</div>` : ''}
                    `);
                // Position is fixed at top-left via CSS, no need to set here
            }
            
            function hideTooltip() {
                tooltip.style('opacity', 0);
            }
            
            function highlightConnections(node) {
                // Get IDs of connected nodes
                const connectedIds = new Set([node.id]);
                links.forEach(l => {
                    if (l.source.id === node.id) connectedIds.add(l.target.id);
                    if (l.target.id === node.id) connectedIds.add(l.source.id);
                });
                
                // Highlight connected links
                linkElements
                    .classed('active', d => d.source.id === node.id || d.target.id === node.id)
                    .style('opacity', d => 
                        (d.source.id === node.id || d.target.id === node.id) ? 1 : 0.15
                    );
                
                // Dim unconnected nodes
                nodeElements
                    .style('opacity', d => connectedIds.has(d.id) ? 1 : 0.2);
                
                // Show labels for selected node and all connected nodes
                nodeElements.each(function(d) {
                    const node = d3.select(this);
                    const label = node.select('text');
                    
                    if (!label.empty()) {
                        label.style('opacity', connectedIds.has(d.id) ? 1 : 0);
                    }
                });
            }
            
            function unhighlightConnections() {
                linkElements
                    .classed('active', false)
                    .style('opacity', 0.6);
                nodeElements.style('opacity', 1);
                
                // Restore labels: only highlighted nodes visible
                nodeElements.each(function(d) {
                    const node = d3.select(this);
                    const label = node.select('text');
                    
                    if (!label.empty()) {
                        label.style('opacity', d.highlighted ? 1 : 0);
                    }
                });
            }
            
            console.log('Force-directed visualization complete:', nodes.length, 'nodes,', links.length, 'links');
        }
    </script>
</body>
</html>